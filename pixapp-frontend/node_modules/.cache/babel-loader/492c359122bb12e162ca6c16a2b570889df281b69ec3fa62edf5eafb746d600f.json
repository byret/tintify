{"ast":null,"code":"import Color from 'color';\nexport const generatePalette = (scheme, baseColor, count) => {\n  const color = Color(baseColor);\n  let colors = [];\n  switch (scheme) {\n    case 'monochromatic':\n      colors = generateMonochromatic(color, count);\n      break;\n    case 'analogous':\n      colors = generateAnalogous(color, count);\n      break;\n    case 'complementary':\n      colors = generateComplementary(color, count);\n      break;\n    case 'split_complementary':\n      colors = generateSplitComplementary(color, count);\n      break;\n    case 'triadic':\n      colors = generateTriadic(color, count);\n      break;\n    case 'square':\n      colors = generateSquare(color, count);\n      break;\n    case 'rectangle':\n      colors = generateTetradic(color, count);\n      break;\n    default:\n      colors = Array(count).fill(baseColor);\n    // Если схема не выбрана, заполняем палитру исходным цветом\n  }\n  return colors;\n};\n\n// Генерация монохромной палитры\nconst generateMonochromatic = (color, count) => {\n  let palette = [];\n  for (let i = 0; i < count; i++) {\n    palette.push(color.lightness(i / count * 100).hex());\n  }\n  return palette;\n};\n\n// Генерация аналоговой палитры\nconst generateAnalogous = (color, count) => {\n  let palette = [];\n  const angle = 30; // Угол между цветами на цветовом круге\n  for (let i = 0; i < count; i++) {\n    palette.push(color.rotate(i * angle).hex());\n  }\n  return palette;\n};\n\n// Генерация дополнительной палитры (комплементарной)\nconst generateComplementary = color => {\n  return [color.hex(), color.rotate(180).hex()];\n};\n\n// Генерация палитры split complementary\nconst generateSplitComplementary = color => {\n  return [color.hex(), color.rotate(150).hex(), color.rotate(-150).hex()];\n};\n\n// Генерация триадической палитры\nconst generateTriadic = color => {\n  return [color.hex(), color.rotate(120).hex(), color.rotate(240).hex()];\n};\n\n// Генерация квадратной палитры\nconst generateSquare = color => {\n  return [color.hex(), color.rotate(90).hex(), color.rotate(180).hex(), color.rotate(270).hex()];\n};\n\n// Генерация тетрадической палитры (прямоугольной)\nconst generateTetradic = color => {\n  return [color.hex(), color.rotate(60).hex(), color.rotate(180).hex(), color.rotate(240).hex()];\n};","map":{"version":3,"names":["Color","generatePalette","scheme","baseColor","count","color","colors","generateMonochromatic","generateAnalogous","generateComplementary","generateSplitComplementary","generateTriadic","generateSquare","generateTetradic","Array","fill","palette","i","push","lightness","hex","angle","rotate"],"sources":["C:/Users/byret/Desktop/pixapp/pixapp-frontend/src/components/colorUtils.js"],"sourcesContent":["import Color from 'color';\r\n\r\nexport const generatePalette = (scheme, baseColor, count) => {\r\n  const color = Color(baseColor);\r\n  let colors = [];\r\n\r\n  switch (scheme) {\r\n    case 'monochromatic':\r\n      colors = generateMonochromatic(color, count);\r\n      break;\r\n    case 'analogous':\r\n      colors = generateAnalogous(color, count);\r\n      break;\r\n    case 'complementary':\r\n      colors = generateComplementary(color, count);\r\n      break;\r\n    case 'split_complementary':\r\n      colors = generateSplitComplementary(color, count);\r\n      break;\r\n    case 'triadic':\r\n      colors = generateTriadic(color, count);\r\n      break;\r\n    case 'square':\r\n      colors = generateSquare(color, count);\r\n      break;\r\n    case 'rectangle':\r\n      colors = generateTetradic(color, count);\r\n      break;\r\n    default:\r\n      colors = Array(count).fill(baseColor);  // Если схема не выбрана, заполняем палитру исходным цветом\r\n  }\r\n\r\n  return colors;\r\n};\r\n\r\n// Генерация монохромной палитры\r\nconst generateMonochromatic = (color, count) => {\r\n  let palette = [];\r\n  for (let i = 0; i < count; i++) {\r\n    palette.push(color.lightness((i / count) * 100).hex());\r\n  }\r\n  return palette;\r\n};\r\n\r\n// Генерация аналоговой палитры\r\nconst generateAnalogous = (color, count) => {\r\n  let palette = [];\r\n  const angle = 30; // Угол между цветами на цветовом круге\r\n  for (let i = 0; i < count; i++) {\r\n    palette.push(color.rotate(i * angle).hex());\r\n  }\r\n  return palette;\r\n};\r\n\r\n// Генерация дополнительной палитры (комплементарной)\r\nconst generateComplementary = (color) => {\r\n  return [color.hex(), color.rotate(180).hex()];\r\n};\r\n\r\n// Генерация палитры split complementary\r\nconst generateSplitComplementary = (color) => {\r\n  return [color.hex(), color.rotate(150).hex(), color.rotate(-150).hex()];\r\n};\r\n\r\n// Генерация триадической палитры\r\nconst generateTriadic = (color) => {\r\n  return [color.hex(), color.rotate(120).hex(), color.rotate(240).hex()];\r\n};\r\n\r\n// Генерация квадратной палитры\r\nconst generateSquare = (color) => {\r\n  return [color.hex(), color.rotate(90).hex(), color.rotate(180).hex(), color.rotate(270).hex()];\r\n};\r\n\r\n// Генерация тетрадической палитры (прямоугольной)\r\nconst generateTetradic = (color) => {\r\n  return [color.hex(), color.rotate(60).hex(), color.rotate(180).hex(), color.rotate(240).hex()];\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}